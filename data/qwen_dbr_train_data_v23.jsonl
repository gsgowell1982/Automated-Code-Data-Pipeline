{"sample_id": "d3bc1500-9b84-402b-ba6a-b56655082abc", "instruction": "请定位 `login` 函数中的异常处理逻辑，并仅抽取尝试捕获 `EntityDoesNotExist` 异常并抛出 `wrong_login_error` 的代码块。", "context": {"file_path": "app\\api\\routes\\authentication.py", "related_dbr": "DBR-01", "code_snippet": "try:\n    user = await users_repo.get_user_by_email(email=user_login.email)\nexcept EntityDoesNotExist as existence_error:\n    raise wrong_login_error from existence_error"}, "auto_processing": {"parser": "multilingual_evidence_aligned_parser", "dbr_logic": "Authentication & Credential Integrity", "data_cleaning": "Language: zh-cn, Logic-block extraction"}, "reasoning_trace": ["根据要求，我们需要从 `login` 函数中提取特定的异常处理部分。这部分代码负责在登录过程中处理用户不存在的情况，并返回一个模糊错误信息。"], "answer": "从 `login` 函数中提取的异常处理代码如下：\n```python\ntry:\n    user = await users_repo.get_user_by_email(email=user_login.email)\nexcept EntityDoesNotExist as existence_error:\n    raise wrong_login_error from existence_error\n```\n\n该代码片段实现了在用户不存在时，抛出一个特定的登录错误。\n\n### Business Logic:\n```python\ntry:\n    user = await users_repo.get_user_by_email(email=user_login.email)\nexcept EntityDoesNotExist as existence_error:\n    raise wrong_login_error from existence_error\n```", "data_quality": {"consistency_check": true, "language": "zh-cn", "temperature": 0.3}}
{"sample_id": "1f9d00eb-9f6d-4b01-b9f2-d27e8321efb0", "instruction": "如何在注册用户时检查用户名和邮箱的唯一性？", "context": {"file_path": "app\\api\\routes\\authentication.py", "related_dbr": "DBR-01", "code_snippet": "if await check_username_is_taken(users_repo, user_create.username):\n    raise HTTPException(\n        detail=strings.USERNAME_TAKEN,\n    )\n\nif await check_email_is_taken(users_repo, user_create.email):\n    raise HTTPException(\n        detail=strings.EMAIL_TAKEN,\n    )"}, "auto_processing": {"parser": "multilingual_evidence_aligned_parser", "dbr_logic": "Authentication & Credential Integrity", "data_cleaning": "Language: zh-cn, Logic-block extraction"}, "reasoning_trace": ["在 `register` 函数中，我们需要调用 `check_username_is_taken` 和 `check_email_is_taken` 方法来确保用户名和邮箱是唯一的。这两个方法将用于验证新用户的输入是否已被其他用户占用。"], "answer": "在 `register` 函数中，通过调用 `check_username_is_taken` 和 `check_email_is_taken` 方法来检查新注册用户的用户名和邮箱是否已被占用。如果已存在，则抛出 400 错误。\n\n### Business Logic:\n```python\nif await check_username_is_taken(users_repo, user_create.username):\n    raise HTTPException(\n        detail=strings.USERNAME_TAKEN,\n    )\n\nif await check_email_is_taken(users_repo, user_create.email):\n    raise HTTPException(\n        detail=strings.EMAIL_TAKEN,\n    )\n```", "data_quality": {"consistency_check": true, "language": "zh-cn", "temperature": 0.3}}
{"sample_id": "2041d931-d49c-4c8d-adf0-bb657ab3d0c4", "instruction": "如何从 `update_current_user` 函数中提取条件式更新的逻辑？", "context": {"file_path": "app\\api\\routes\\users.py", "related_dbr": "DBR-01", "code_snippet": "if user_update.email and user_update.email != current_user.email:\n    if await check_email_is_taken(users_repo, user_update.email):\n        raise HTTPException(\n            detail=strings.EMAIL_TAKEN,\n        )"}, "auto_processing": {"parser": "multilingual_evidence_aligned_parser", "dbr_logic": "Authentication & Credential Integrity", "data_cleaning": "Language: zh-cn, Logic-block extraction"}, "reasoning_trace": ["需要定位 `update_current_user` 函数，并仅抽取对比新旧值 (user_update.email != current_user.email) 的校验逻辑。"], "answer": "从 `update_current_user` 函数中提取的条件式更新逻辑如下：\n```python\nif user_update.email and user_update.email != current_user.email:\n    if await check_email_is_taken(users_repo, user_update.email):\n        raise HTTPException(\n            status_code=HTTP_400_BAD_REQUEST,\n            detail=strings.EMAIL_TAKEN,\n        )\n```\n\n### Business Logic:\n```python\nif user_update.email and user_update.email != current_user.email:\n    if await check_email_is_taken(users_repo, user_update.email):\n        raise HTTPException(\n            detail=strings.EMAIL_TAKEN,\n        )\n```", "data_quality": {"consistency_check": true, "language": "zh-cn", "temperature": 0.3}}
