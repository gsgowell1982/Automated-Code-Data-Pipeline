{
  "rule_id": "DBR-01",
  "rule_name": "Authentication & Credential Integrity",
  "rule_name_cn": "身份准入与账户凭据完整性",
  "description": "This rule ensures authentication and credential integrity through: (1) Multi-scenario uniqueness interception during sign-up and update, (2) Account security and storage atomicity with password hashing, (3) Authentication security feedback with vague error messages, (4) Dynamic session state maintenance via JWT token refresh.",
  "description_cn": "本规则通过以下机制确保身份准入与账户凭据完整性：（1）注册及更新时的多场景唯一性拦截；（2）账户安全性与存储原子性（密码哈希）；（3）身份验证安全反馈（模糊错误信息）；（4）动态会话状态维护（JWT令牌刷新）。",
  "version": "1.0.0",
  "created_at": "2026-01-28T06:05:54.857075",
  "analysis_source": "/workspace/data/fastapi_analysis_result.json",
  "project_name": "fastapi-realworld-example-app",
  "subcategories": [
    {
      "subcategory_id": "DBR-01-01",
      "name": "Multi-scenario Uniqueness Interception",
      "name_cn": "多场景唯一性拦截",
      "description": "System enforces uniqueness checks during user registration and profile updates. If identifier is already taken, system explicitly intercepts with 400 Bad Request.",
      "description_cn": "系统在用户注册及资料更新时，强制执行唯一性检查。若标识符已被占用，系统通过 400 Bad Request 显式拦截。",
      "evidences": [
        {
          "evidence_id": "DBR-01-REGISTER-PRECHECK",
          "evidence_type": "pattern",
          "name": "Registration Pre-check Logic",
          "description": "System receives user_create as input parameter. Before calling users_repo.create_user, it awaits check_username_is_taken and check_email_is_taken. If any identifier is taken, raises HTTP_400_BAD_REQUEST.",
          "description_cn": "系统接收 user_create 作为输入参数。在调用 users_repo.create_user 之前，通过 await 执行 check_username_is_taken 和 check_email_is_taken。若其中任一服务判定标识符已被占用，则抛出对应的 HTTP_400_BAD_REQUEST。",
          "location": {
            "file_path": "app/api/routes/authentication.py",
            "module_name": "app.api.routes.authentication",
            "line_start": 62,
            "line_end": 93,
            "qualified_name": "app.api.routes.authentication.register"
          },
          "related_elements": [
            "user_create",
            "check_username_is_taken",
            "check_email_is_taken",
            "users_repo.create_user",
            "HTTP_400_BAD_REQUEST",
            "USERNAME_TAKEN",
            "EMAIL_TAKEN"
          ],
          "metadata": {
            "complexity": 3,
            "parameters": [
              "user_create",
              "users_repo",
              "settings"
            ],
            "calls": [
              "Body",
              "Depends",
              "get_repository",
              "Depends",
              "check_username_is_taken",
              "HTTPException",
              "check_email_is_taken",
              "HTTPException",
              "users_repo.create_user",
              "user_create.dict",
              "jwt.create_access_token_for_user",
              "str",
              "settings.secret_key.get_secret_value",
              "UserInResponse",
              "UserWithToken",
              "router.post"
            ],
            "has_user_create_param": true,
            "has_check_username": true,
            "has_check_email": true,
            "has_create_user": true
          }
        },
        {
          "evidence_id": "DBR-01-UPDATE-CONDITIONAL",
          "evidence_type": "pattern",
          "name": "Conditional Update Validation",
          "description": "System compares user_update attributes with current_user's original attributes. Only triggers check_username_is_taken or check_email_is_taken when the values differ from existing ones.",
          "description_cn": "系统对比 user_update 传入的属性与 current_user 的原始属性。仅当 user_update.username 或 user_update.email 与现有值不一致时，才会触发 check_username_is_taken 或 check_email_is_taken 的查重逻辑。",
          "location": {
            "file_path": "app/api/routes/users.py",
            "module_name": "app.api.routes.users",
            "line_start": 39,
            "line_end": 73,
            "qualified_name": "app.api.routes.users.update_current_user"
          },
          "related_elements": [
            "user_update",
            "current_user",
            "user_update.username",
            "user_update.email",
            "current_user.username",
            "current_user.email",
            "check_username_is_taken",
            "check_email_is_taken"
          ],
          "metadata": {
            "complexity": 7,
            "parameters": [
              "user_update",
              "current_user",
              "users_repo",
              "settings"
            ],
            "calls": [
              "Body",
              "Depends",
              "get_current_user_authorizer",
              "Depends",
              "get_repository",
              "Depends",
              "check_username_is_taken",
              "HTTPException",
              "check_email_is_taken",
              "HTTPException",
              "users_repo.update_user",
              "user_update.dict",
              "jwt.create_access_token_for_user",
              "str",
              "settings.secret_key.get_secret_value",
              "UserInResponse",
              "UserWithToken",
              "router.put"
            ],
            "has_user_update_param": true,
            "has_current_user_param": true,
            "has_conditional_logic": true
          }
        },
        {
          "evidence_id": "DBR-01-SERVICE-CHECK-USERNAME-IS-TAKEN",
          "evidence_type": "function",
          "name": "Uniqueness Service: check_username_is_taken",
          "description": "The check_username_is_taken function queries the repository and catches EntityDoesNotExist to determine availability.",
          "description_cn": "函数 check_username_is_taken 查询仓库并捕获 EntityDoesNotExist 异常来判断唯一性。",
          "location": {
            "file_path": "app/services/authentication.py",
            "module_name": "app.services.authentication",
            "line_start": 5,
            "line_end": 11,
            "qualified_name": "app.services.authentication.check_username_is_taken"
          },
          "related_elements": [
            "check_username_is_taken",
            "EntityDoesNotExist",
            "UsersRepository"
          ],
          "metadata": {
            "calls": [
              "repo.get_user_by_username"
            ],
            "return_type": "bool"
          }
        },
        {
          "evidence_id": "DBR-01-SERVICE-CHECK-EMAIL-IS-TAKEN",
          "evidence_type": "function",
          "name": "Uniqueness Service: check_email_is_taken",
          "description": "The check_email_is_taken function queries the repository and catches EntityDoesNotExist to determine availability.",
          "description_cn": "函数 check_email_is_taken 查询仓库并捕获 EntityDoesNotExist 异常来判断唯一性。",
          "location": {
            "file_path": "app/services/authentication.py",
            "module_name": "app.services.authentication",
            "line_start": 14,
            "line_end": 20,
            "qualified_name": "app.services.authentication.check_email_is_taken"
          },
          "related_elements": [
            "check_email_is_taken",
            "EntityDoesNotExist",
            "UsersRepository"
          ],
          "metadata": {
            "calls": [
              "repo.get_user_by_email"
            ],
            "return_type": "bool"
          }
        }
      ]
    },
    {
      "subcategory_id": "DBR-01-02",
      "name": "Account Security & Storage Atomicity",
      "name_cn": "账户安全性与存储原子性",
      "description": "Account creation process ensures atomicity through UsersRepository. Password is hashed before persistence.",
      "description_cn": "账户创建过程通过 UsersRepository 确保原子性，密码经哈希处理后持久化。",
      "evidences": [
        {
          "evidence_id": "DBR-01-REPO-ATOMICITY",
          "evidence_type": "pattern",
          "name": "Repository Storage Atomicity",
          "description": "Account creation through UsersRepository ensures atomicity using database transaction. Password is hashed via change_password before persistence.",
          "description_cn": "账户创建过程通过 UsersRepository 确保原子性，密码经哈希处理后持久化。使用数据库事务保证操作的原子性。",
          "location": {
            "file_path": "app/db/repositories/users.py",
            "module_name": "app.db.repositories.users",
            "line_start": 29,
            "line_end": 48,
            "qualified_name": "app.db.repositories.users.UsersRepository.create_user"
          },
          "related_elements": [
            "UsersRepository",
            "create_user",
            "change_password",
            "self.connection.transaction",
            "hashed_password",
            "salt"
          ],
          "metadata": {
            "has_transaction": true,
            "has_password_change": true,
            "has_create_query": true,
            "calls": [
              "UserInDB",
              "user.change_password",
              "self.connection.transaction",
              "queries.create_new_user",
              "user.copy",
              "dict"
            ]
          }
        }
      ]
    },
    {
      "subcategory_id": "DBR-01-03",
      "name": "Authentication Security Feedback",
      "name_cn": "身份验证安全反馈",
      "description": "Login uniformly catches exceptions and returns vague error message INCORRECT_LOGIN_INPUT to prevent user enumeration attacks.",
      "description_cn": "登录时统一捕获异常，返回模糊错误信息 INCORRECT_LOGIN_INPUT，防止用户枚举。",
      "evidences": [
        {
          "evidence_id": "DBR-01-LOGIN-EXCEPTION",
          "evidence_type": "exception_handling",
          "name": "Unified Login Exception Handling",
          "description": "System predefines wrong_login_error variable. Uses try-except to catch EntityDoesNotExist (named as existence_error). Returns vague error message INCORRECT_LOGIN_INPUT to prevent user enumeration.",
          "description_cn": "系统预定义了 wrong_login_error 变量。通过 try-except 结构捕获 EntityDoesNotExist（命名为 existence_error），若捕获到该异常或 user.check_password 返回为假，则统一抛出 wrong_login_error。",
          "location": {
            "file_path": "app/api/routes/authentication.py",
            "module_name": "app.api.routes.authentication",
            "line_start": 23,
            "line_end": 53,
            "qualified_name": "app.api.routes.authentication.login"
          },
          "related_elements": [
            "wrong_login_error",
            "existence_error",
            "EntityDoesNotExist",
            "INCORRECT_LOGIN_INPUT",
            "user.check_password"
          ],
          "metadata": {
            "complexity": 3,
            "local_variables": [
              "token",
              "wrong_login_error",
              "user"
            ],
            "calls": [
              "Body",
              "Depends",
              "get_repository",
              "Depends",
              "HTTPException",
              "users_repo.get_user_by_email",
              "user.check_password",
              "jwt.create_access_token_for_user",
              "str",
              "settings.secret_key.get_secret_value",
              "UserInResponse",
              "UserWithToken",
              "router.post"
            ],
            "has_wrong_login_error": true,
            "has_check_password_call": true,
            "has_get_user_by_email": true
          }
        }
      ]
    },
    {
      "subcategory_id": "DBR-01-04",
      "name": "Dynamic Session State Maintenance",
      "name_cn": "动态会话状态维护",
      "description": "After successful operation, system regenerates and returns JWT token to maintain client session state consistency.",
      "description_cn": "操作成功后重新生成并返回 JWT 令牌，维持客户端会话状态一致性。",
      "evidences": [
        {
          "evidence_id": "DBR-01-TOKEN-LOGIN",
          "evidence_type": "call",
          "name": "Token Refresh in login",
          "description": "The login function calls jwt.create_access_token_for_user to generate token variable, wrapped in UserWithToken domain model.",
          "description_cn": "函数 login 通过调用 jwt.create_access_token_for_user 生成 token 变量，并封装在 UserWithToken 领域模型中返回。",
          "location": {
            "file_path": "app/api/routes/authentication.py",
            "module_name": "app.api.routes.authentication",
            "line_start": 23,
            "line_end": 53,
            "qualified_name": "app.api.routes.authentication.login"
          },
          "related_elements": [
            "jwt.create_access_token_for_user",
            "token",
            "UserWithToken",
            "UserInResponse"
          ],
          "metadata": {
            "function_name": "login",
            "has_create_token": true,
            "has_token_var": true,
            "has_user_with_token": true,
            "calls": [
              "Body",
              "Depends",
              "get_repository",
              "Depends",
              "HTTPException",
              "users_repo.get_user_by_email",
              "user.check_password",
              "jwt.create_access_token_for_user",
              "str",
              "settings.secret_key.get_secret_value",
              "UserInResponse",
              "UserWithToken",
              "router.post"
            ]
          }
        },
        {
          "evidence_id": "DBR-01-TOKEN-REGISTER",
          "evidence_type": "call",
          "name": "Token Refresh in register",
          "description": "The register function calls jwt.create_access_token_for_user to generate token variable, wrapped in UserWithToken domain model.",
          "description_cn": "函数 register 通过调用 jwt.create_access_token_for_user 生成 token 变量，并封装在 UserWithToken 领域模型中返回。",
          "location": {
            "file_path": "app/api/routes/authentication.py",
            "module_name": "app.api.routes.authentication",
            "line_start": 62,
            "line_end": 93,
            "qualified_name": "app.api.routes.authentication.register"
          },
          "related_elements": [
            "jwt.create_access_token_for_user",
            "token",
            "UserWithToken",
            "UserInResponse"
          ],
          "metadata": {
            "function_name": "register",
            "has_create_token": true,
            "has_token_var": true,
            "has_user_with_token": true,
            "calls": [
              "Body",
              "Depends",
              "get_repository",
              "Depends",
              "check_username_is_taken",
              "HTTPException",
              "check_email_is_taken",
              "HTTPException",
              "users_repo.create_user",
              "user_create.dict",
              "jwt.create_access_token_for_user",
              "str",
              "settings.secret_key.get_secret_value",
              "UserInResponse",
              "UserWithToken",
              "router.post"
            ]
          }
        },
        {
          "evidence_id": "DBR-01-TOKEN-RETRIEVE_CURRENT_USER",
          "evidence_type": "call",
          "name": "Token Refresh in retrieve_current_user",
          "description": "The retrieve_current_user function calls jwt.create_access_token_for_user to generate token variable, wrapped in UserWithToken domain model.",
          "description_cn": "函数 retrieve_current_user 通过调用 jwt.create_access_token_for_user 生成 token 变量，并封装在 UserWithToken 领域模型中返回。",
          "location": {
            "file_path": "app/api/routes/users.py",
            "module_name": "app.api.routes.users",
            "line_start": 19,
            "line_end": 35,
            "qualified_name": "app.api.routes.users.retrieve_current_user"
          },
          "related_elements": [
            "jwt.create_access_token_for_user",
            "token",
            "UserWithToken",
            "UserInResponse"
          ],
          "metadata": {
            "function_name": "retrieve_current_user",
            "has_create_token": true,
            "has_token_var": true,
            "has_user_with_token": true,
            "calls": [
              "Depends",
              "get_current_user_authorizer",
              "Depends",
              "jwt.create_access_token_for_user",
              "str",
              "settings.secret_key.get_secret_value",
              "UserInResponse",
              "UserWithToken",
              "router.get"
            ]
          }
        },
        {
          "evidence_id": "DBR-01-TOKEN-UPDATE_CURRENT_USER",
          "evidence_type": "call",
          "name": "Token Refresh in update_current_user",
          "description": "The update_current_user function calls jwt.create_access_token_for_user to generate token variable, wrapped in UserWithToken domain model.",
          "description_cn": "函数 update_current_user 通过调用 jwt.create_access_token_for_user 生成 token 变量，并封装在 UserWithToken 领域模型中返回。",
          "location": {
            "file_path": "app/api/routes/users.py",
            "module_name": "app.api.routes.users",
            "line_start": 39,
            "line_end": 73,
            "qualified_name": "app.api.routes.users.update_current_user"
          },
          "related_elements": [
            "jwt.create_access_token_for_user",
            "token",
            "UserWithToken",
            "UserInResponse"
          ],
          "metadata": {
            "function_name": "update_current_user",
            "has_create_token": true,
            "has_token_var": true,
            "has_user_with_token": true,
            "calls": [
              "Body",
              "Depends",
              "get_current_user_authorizer",
              "Depends",
              "get_repository",
              "Depends",
              "check_username_is_taken",
              "HTTPException",
              "check_email_is_taken",
              "HTTPException",
              "users_repo.update_user",
              "user_update.dict",
              "jwt.create_access_token_for_user",
              "str",
              "settings.secret_key.get_secret_value",
              "UserInResponse",
              "UserWithToken",
              "router.put"
            ]
          }
        }
      ]
    }
  ],
  "related_files": [
    "app/api/routes/authentication.py",
    "app/api/routes/users.py",
    "app/db/repositories/users.py",
    "app/services/authentication.py"
  ],
  "related_functions": [
    "app.api.routes.authentication.login",
    "app.api.routes.authentication.register",
    "app.api.routes.users.retrieve_current_user",
    "app.api.routes.users.update_current_user",
    "app.db.repositories.users.UsersRepository.create_user",
    "app.services.authentication.check_email_is_taken",
    "app.services.authentication.check_username_is_taken"
  ],
  "dependencies": [
    "fastapi",
    "starlette",
    "jwt",
    "pydantic"
  ],
  "tags": [
    "authentication",
    "security",
    "credential",
    "jwt",
    "user-management",
    "uniqueness-check",
    "password-hashing"
  ]
}